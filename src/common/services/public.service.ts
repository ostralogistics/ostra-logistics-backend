import {
  ConflictException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { NewsLetterEntity } from 'src/Entity/newsletter.entity';
import { Notifications } from 'src/Entity/notifications.entity';
import { OrderEntity } from 'src/Entity/orders.entity';
import { NewsLetterDto } from 'src/customer/customer.dto';
import { NewsLetterRepository } from 'src/customer/customer.repository';
import { IOrder } from 'src/order/order';
import { OrderRepository } from 'src/order/order.reposiroty';
import { ILike } from 'typeorm';
import { NotificationRepository } from '../common.repositories';
import { TaskEntity } from 'src/Entity/ridersTasks.entity';
import { TaskRepository } from 'src/Riders/riders.repository';

@Injectable()
export class PublicService {
  constructor(
    @InjectRepository(OrderEntity) private readonly orderripo: OrderRepository,
    @InjectRepository(NewsLetterEntity)
    private readonly newsletterripo: NewsLetterRepository,
    @InjectRepository(Notifications)
    private readonly notificationripo: NotificationRepository,
    @InjectRepository(TaskEntity) private readonly taskRepo: TaskRepository,
  ) {}

  //  track order (un guarded)
  async TrackOrder(keyword: string) {
    try {
      //find order
      const trackorder = await this.orderripo.findOne({
        where: { trackingID: ILike(`%${keyword}`) },
        cache: false,
        comment:
          'tracking order with the trackingToken generated by the system',
      });
      if (!trackorder)
        throw new NotFoundException(
          `oops! this trackingID ${keyword} is not associated with any order in ostra logistics`,
        );

      //find a rider task associated wit this orderassigned_order.items
      const task = await this.taskRepo.findOne({
        where: { assigned_order: trackorder },
        relations:['assigned_order','assigned_order.items','assigned_order.items.vehicleType','assigned_order.customer','rider']
      });

      if (!task) throw new NotFoundException('ride associated with order not found')

      return task;
    } catch (error) {
      if (error instanceof NotFoundException)
        throw new NotFoundException(error.message);
      else {
        console.log(error);
        throw new InternalServerErrorException(
          'something went wrong while tracking order,',error.message
        );
      }
    }
  }

  //scan barcode for an order (un guarded)
  async scanBarcode(barcode: string) {
    try {
      const order = await this.orderripo.findOne({
        where: { barcodeDigits: barcode },
        comment: 'finding order with the trackingID scanned from the barcode',
      });
      if (!order)
        throw new NotFoundException(
          `Oops! Order associated with barcode ${barcode} is not found`,
        );

        const task = await this.taskRepo.findOne({
          where: { assigned_order: order },
          relations:['assigned_order','assigned_order.items','assigned_order.items.vehicleType','assigned_order.customer','rider']
        });
  
        if (!task) throw new NotFoundException('ride associated with order not found')
  
        return task;
    } catch (error) {
      if (error instanceof NotFoundException)
        throw new NotFoundException(error.message);
      else {
        console.log(error);
        throw new InternalServerErrorException(
          'something went wrong while scanning the barcode to get order status, please try again later',
        );
      }
    }
  }

  // sign up for newsletter
  async SubsribeToNewsLetter(dto: NewsLetterDto) {
    try {
      const emailExists = await this.newsletterripo.findOne({
        where: { email: dto.email },
      });
      if (emailExists)
        throw new ConflictException(
          'user with email address already subscribed, please use another email address',
        );

      //subscribe
      const newSubscriber = new NewsLetterEntity();
      newSubscriber.email = dto.email;
      newSubscriber.firstname = dto.firstname;
      newSubscriber.lastname = dto.lastname;
      newSubscriber.SubscribedAt = new Date();

      await this.newsletterripo.save(newSubscriber);

      //notifiction
      const notification = new Notifications();
      notification.account = dto.email;
      notification.subject = 'News Letter Subscription!';
      notification.message = `the customer with email ${newSubscriber.email} have sunscribed to the ostra logistics news letter `;
      await this.notificationripo.save(notification);

      return {
        message:
          'you have successully subscribed to ostra logistics news letter',
      };
    } catch (error) {
      if (error instanceof ConflictException)
        throw new ConflictException(error.message);
      else {
        console.log(error);
        throw new InternalServerErrorException(
          'something went wrong while subscribing for news letter, please try again later',
        );
      }
    }
  }
}
